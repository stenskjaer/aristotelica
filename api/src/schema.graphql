type Text {
  id: ID!
  # This is a clear ontology conflict between these two things!
  authors: [Person!]! @cypher(statement: "MATCH (this)<--(:Attribution)-->(p:Person) RETURN DISTINCT p")
  authorName: String! @cypher(statement: "MATCH (this)<--(:Attribution)-->(p:Person) RETURN p.name")
  title: String!
  title_addon: String
  created: DateTime!
  modified: String
  date: String
  note: String
  type: [TextType]! @relation(name: "Type", direction: "OUT")
}

type Person {
  id: ID!
  name: String!
  created: String!
  modified: String
  note: String 
}

type TextType {
  id: ID!
  name: String!
}

type User {
  id: ID!
  name: String
  friends: [User] @relation(name: "FRIENDS", direction: "BOTH")
  reviews: [Review] @relation(name: "WROTE", direction: "OUT")
  avgStars: Float @cypher(statement: "MATCH (this)-[:WROTE]->(r:Review) RETURN toFloat(avg(r.stars))")
  numReviews: Int @cypher(statement: "MATCH (this)-[:WROTE]->(r:Review) RETURN COUNT(r)")
}

type Business {
  id: ID!
  name: String
  address: String
  city: String
  state: String
  reviews: [Review] @relation(name: "REVIEWS", direction: "IN")
  categories: [Category] @relation(name: "IN_CATEGORY", direction: "OUT")
}

type Review {
  id: ID!
  stars: Int
  text: String
  business: Business @relation(name: "REVIEWS", direction: "OUT")
  user: User @relation(name: "WROTE", direction: "IN")
}

type Category {
  name: ID!
  businesses: [Business] @relation(name: "IN_CATEGORY", direction: "IN")
}

scalar DateTime

type Query {
  textByTitle(substring: String): [Text] @cypher(statement: "MATCH (t:Text) WHERE lower(t.title) CONTAINS lower($substring) RETURN t")
  textById(ID: String!): Text @cypher(statement: "MATCH (t:Text) WHERE t.text_id = $ID RETURN t")
  usersBySubstring(substring: String, first: Int = 10, offset: Int = 0): [User] @cypher(statement: "MATCH (u:User) WHERE u.name CONTAINS $substring RETURN u")
}
